"""P√°gina de Relat√≥rios Avan√ßados"""
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
from database.db_manager import DatabaseManager
from utils.pdf_reports import PDFReportGenerator
from utils.data_analyzer import DataAnalyzer
import os

st.set_page_config(page_title="Relat√≥rios", page_icon="üìÑ", layout="wide")
st.title("üìÑ Relat√≥rios Avan√ßados")
st.markdown("*Sistema completo de gera√ß√£o de relat√≥rios com dados consolidados de todos os pain√©is*")

# Carregar dados diretamente da base de dados
df_inicial = DatabaseManager.get_dashboard_data()
if df_inicial.empty:
    st.warning("‚ö†Ô∏è Nenhum dado encontrado. Fa√ßa upload de arquivos CSV primeiro.")
    st.stop()
else:
    st.success(f"‚úÖ Dados carregados: {len(df_inicial):,} registros para gera√ß√£o de relat√≥rios")

# Carregar dados com cache para performance
@st.cache_data(ttl=300)  # Cache por 5 minutos
def load_report_data():
    """Carrega dados otimizados para relat√≥rios"""
    try:
        df = DatabaseManager.get_dashboard_data()
        summary = DatabaseManager.get_fleet_summary()
        
        if df.empty:
            return None, None
            
        return df, summary
    except Exception as e:
        st.error(f"Erro ao carregar dados: {str(e)}")
        return None, None

# Configura√ß√µes do relat√≥rio
st.sidebar.header("‚öôÔ∏è Configura√ß√µes do Relat√≥rio")

# Filtros de per√≠odo
periodo_opcoes = {
    "√öltimos 7 dias": 7,
    "√öltimos 30 dias": 30,
    "√öltimos 90 dias": 90,
    "Todos os dados": None
}

periodo_selecionado = st.sidebar.selectbox(
    "üìÖ Per√≠odo:",
    options=list(periodo_opcoes.keys()),
    index=1  # Padr√£o: √∫ltimos 30 dias
)

# Tipos de relat√≥rio
tipo_relatorio = st.sidebar.selectbox(
    "üìä Tipo de Relat√≥rio:",
    [
        "üìã Relat√≥rio Executivo Completo",
        "üöó An√°lise Detalhada por Ve√≠culo", 
        "‚ö° Relat√≥rio de Performance",
        "üö® Relat√≥rio de Conformidade",
        "üìà An√°lise de Tend√™ncias",
        "üîç Relat√≥rio Personalizado"
    ]
)

# Op√ß√µes de formato
formato_saida = st.sidebar.selectbox(
    "üìÑ Formato:",
    ["PDF Profissional", "Visualiza√ß√£o Web", "Dados CSV", "Relat√≥rio Completo (PDF + CSV)"]
)

# Incluir gr√°ficos
incluir_graficos = st.sidebar.checkbox("üìä Incluir Gr√°ficos", value=True)
incluir_mapas = st.sidebar.checkbox("üó∫Ô∏è Incluir Mapas", value=False)

# Carregar dados
df, summary = load_report_data()

if df is None or df.empty:
    st.error("‚ùå N√£o foi poss√≠vel carregar os dados para o relat√≥rio.")
    st.stop()

# Filtrar dados por per√≠odo se especificado - com valida√ß√£o de tipo
df_filtered = df.copy()

# Converter coluna de data para datetime de forma segura
if 'data' in df_filtered.columns:
    df_filtered['data'] = pd.to_datetime(df_filtered['data'], errors='coerce')
    df_filtered = df_filtered.dropna(subset=['data'])

if periodo_opcoes[periodo_selecionado] is not None:
    dias = periodo_opcoes[periodo_selecionado]
    cutoff_date = datetime.now() - timedelta(days=dias)
    
    # Filtrar apenas se a coluna de data est√° dispon√≠vel e foi convertida com sucesso
    if 'data' in df_filtered.columns and not df_filtered.empty:
        # Verificar se a coluna de data tem timezone e ajustar a compara√ß√£o
        if hasattr(df_filtered['data'].dtype, 'tz') and df_filtered['data'].dtype.tz is not None:
            # Se dados t√™m timezone, converter cutoff_date para timezone-aware
            from datetime import timezone
            cutoff_date = cutoff_date.replace(tzinfo=timezone.utc)
        else:
            # Se dados s√£o naive, garantir que cutoff_date tamb√©m seja naive
            cutoff_date = cutoff_date.replace(tzinfo=None)
        
        df_filtered = df_filtered[df_filtered['data'] >= cutoff_date]
        st.info(f"üìÖ Dados filtrados: {len(df_filtered):,} registros dos √∫ltimos {dias} dias")
    else:
        st.warning("‚ö†Ô∏è N√£o foi poss√≠vel filtrar por per√≠odo - dados de data indispon√≠veis")
else:
    st.info(f"üìÖ Usando todos os dados: {len(df_filtered):,} registros")

# An√°lise preliminar para o relat√≥rio
analyzer = DataAnalyzer(df_filtered)

# ========== DEFINI√á√ïES DAS FUN√á√ïES ==========

def show_report_preview(df, summary, analyzer, tipo_relatorio):
    """Mostra pr√©-visualiza√ß√£o do relat√≥rio"""
    st.subheader("üëÅÔ∏è Pr√©-visualiza√ß√£o do Relat√≥rio")
    
    # Estat√≠sticas gerais
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("üìä Total de Registros", f"{len(df):,}")
    with col2:
        st.metric("üöó Ve√≠culos", f"{df['placa'].nunique()}")
    with col3:
        st.metric("üè¢ Clientes", f"{df['cliente'].nunique()}")
    with col4:
        st.metric("üìÖ Per√≠odo", f"{(df['data'].max() - df['data'].min()).days} dias")
    
    # Conte√∫do baseado no tipo de relat√≥rio
    if "Executivo" in tipo_relatorio:
        show_executive_preview(df, summary, analyzer)
    elif "Ve√≠culo" in tipo_relatorio:
        show_vehicle_preview(df, analyzer)
    elif "Performance" in tipo_relatorio:
        show_performance_preview(df, analyzer)
    elif "Conformidade" in tipo_relatorio:
        show_compliance_preview(df, analyzer)
    elif "Tend√™ncias" in tipo_relatorio:
        show_trends_preview(df, analyzer)
    else:
        show_custom_preview(df, analyzer)

def show_executive_preview(df, summary, analyzer):
    """Preview do relat√≥rio executivo"""
    st.markdown("### üìã Resumo Executivo")
    
    # KPIs principais
    col1, col2, col3 = st.columns(3)
    
    with col1:
        velocidade_media = df['velocidade_km'].mean()
        st.metric("‚ö° Velocidade M√©dia", f"{velocidade_media:.1f} km/h")
        
    with col2:
        gps_coverage = (df['gps'].sum() / len(df)) * 100
        st.metric("üì° Cobertura GPS", f"{gps_coverage:.1f}%")
        
    with col3:
        utilizacao = len(df[df['velocidade_km'] > 0]) / len(df) * 100
        st.metric("üöó Taxa de Utiliza√ß√£o", f"{utilizacao:.1f}%")
    
    # Gr√°fico de utiliza√ß√£o por ve√≠culo
    vehicle_usage = df.groupby('placa').agg({
        'velocidade_km': 'mean',
        'data': 'count'
    }).reset_index()
    vehicle_usage.columns = ['Ve√≠culo', 'Velocidade M√©dia', 'Registros']
    
    fig = px.bar(vehicle_usage, x='Ve√≠culo', y='Registros', 
                 title="üìä Registros por Ve√≠culo")
    st.plotly_chart(fig, use_container_width=True)

def show_vehicle_preview(df, analyzer):
    """Preview da an√°lise por ve√≠culo"""
    st.markdown("### üöó An√°lise por Ve√≠culo")
    
    # Sele√ß√£o de ve√≠culo
    veiculos = sorted(df['placa'].unique())
    veiculo_selecionado = st.selectbox("Selecione um ve√≠culo:", veiculos)
    
    df_veiculo = df[df['placa'] == veiculo_selecionado]
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("üìä Registros", f"{len(df_veiculo):,}")
    with col2:
        vel_media = df_veiculo['velocidade_km'].mean()
        st.metric("‚ö° Velocidade M√©dia", f"{vel_media:.1f} km/h")
    with col3:
        vel_max = df_veiculo['velocidade_km'].max()
        st.metric("üèéÔ∏è Velocidade M√°xima", f"{vel_max:.1f} km/h")
    with col4:
        utilizacao = len(df_veiculo[df_veiculo['velocidade_km'] > 0]) / len(df_veiculo) * 100
        st.metric("üìà Utiliza√ß√£o", f"{utilizacao:.1f}%")
    
    # Gr√°fico de velocidade ao longo do tempo
    df_veiculo_sample = df_veiculo.sample(min(500, len(df_veiculo)))
    fig = px.line(df_veiculo_sample, x='data', y='velocidade_km',
                  title=f"üìà Velocidade ao Longo do Tempo - {veiculo_selecionado}")
    st.plotly_chart(fig, use_container_width=True)

def show_performance_preview(df, analyzer):
    """Preview do relat√≥rio de performance"""
    st.markdown("### ‚ö° An√°lise de Performance")
    
    # Top performers
    performance = df.groupby('placa').agg({
        'velocidade_km': 'mean',
        'odometro_periodo_km': 'sum',
        'data': 'count'
    }).reset_index()
    performance.columns = ['Ve√≠culo', 'Velocidade M√©dia', 'KM Total', 'Registros']
    performance = performance.sort_values('KM Total', ascending=False)
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("**üèÜ Top 5 - Maior Quilometragem**")
        top_km = performance.head(5)
        st.dataframe(top_km[['Ve√≠culo', 'KM Total']], hide_index=True)
        
    with col2:
        st.markdown("**‚ö° Top 5 - Maior Velocidade M√©dia**")
        top_speed = performance.sort_values('Velocidade M√©dia', ascending=False).head(5)
        st.dataframe(top_speed[['Ve√≠culo', 'Velocidade M√©dia']], hide_index=True)
    
    # Gr√°fico de efici√™ncia
    fig = px.scatter(performance, x='Velocidade M√©dia', y='KM Total', 
                     size='Registros', text='Ve√≠culo',
                     title="üìä Matriz de Performance: Velocidade vs Quilometragem")
    st.plotly_chart(fig, use_container_width=True)

def show_compliance_preview(df, analyzer):
    """Preview do relat√≥rio de conformidade"""
    st.markdown("### üö® An√°lise de Conformidade")
    
    # An√°lise de velocidade
    excesso_velocidade = df[df['velocidade_km'] > 80]
    violacoes_criticas = df[df['velocidade_km'] > 100]
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric("‚ö†Ô∏è Excessos de Velocidade", len(excesso_velocidade))
    with col2:
        st.metric("üö® Viola√ß√µes Cr√≠ticas", len(violacoes_criticas))
    with col3:
        conformidade = (1 - len(excesso_velocidade) / len(df)) * 100
        st.metric("‚úÖ Taxa de Conformidade", f"{conformidade:.1f}%")
    
    if len(excesso_velocidade) > 0:
        # Ve√≠culos com mais viola√ß√µes
        violacoes_por_veiculo = excesso_velocidade.groupby('placa').size().reset_index(name='Viola√ß√µes')
        violacoes_por_veiculo = violacoes_por_veiculo.sort_values('Viola√ß√µes', ascending=False)
        
        fig = px.bar(violacoes_por_veiculo.head(10), x='placa', y='Viola√ß√µes',
                     title="üö® Ve√≠culos com Mais Viola√ß√µes de Velocidade")
        st.plotly_chart(fig, use_container_width=True)

def show_trends_preview(df, analyzer):
    """Preview da an√°lise de tend√™ncias"""
    st.markdown("### üìà An√°lise de Tend√™ncias")
    
    # Tend√™ncias por dia
    df['dia'] = df['data'].dt.date
    tendencias_diarias = df.groupby('dia').agg({
        'velocidade_km': 'mean',
        'data': 'count'
    }).reset_index()
    tendencias_diarias.columns = ['Data', 'Velocidade M√©dia', 'Registros']
    
    col1, col2 = st.columns(2)
    
    with col1:
        fig1 = px.line(tendencias_diarias, x='Data', y='Velocidade M√©dia',
                       title="üìà Tend√™ncia de Velocidade M√©dia")
        st.plotly_chart(fig1, use_container_width=True)
        
    with col2:
        fig2 = px.line(tendencias_diarias, x='Data', y='Registros',
                       title="üìä Tend√™ncia de Atividade")
        st.plotly_chart(fig2, use_container_width=True)

def show_custom_preview(df, analyzer):
    """Preview do relat√≥rio personalizado"""
    st.markdown("### üîç Relat√≥rio Personalizado")
    st.info("Configure suas m√©tricas personalizadas na aba Configura√ß√µes")

def show_report_dashboard(df, analyzer):
    """Dashboard interativo do relat√≥rio"""
    st.subheader("üìä Dashboard Interativo")
    
    # Filtros interativos
    col1, col2, col3 = st.columns(3)
    
    with col1:
        veiculos_selecionados = st.multiselect(
            "üöó Ve√≠culos:",
            options=sorted(df['placa'].unique()),
            default=sorted(df['placa'].unique())[:5]  # Primeiros 5 por padr√£o
        )
    
    with col2:
        data_inicio = st.date_input("üìÖ Data In√≠cio:", value=df['data'].min().date())
    
    with col3:
        data_fim = st.date_input("üìÖ Data Fim:", value=df['data'].max().date())
    
    # Filtrar dados
    df_filtered = df[
        (df['placa'].isin(veiculos_selecionados)) &
        (df['data'].dt.date >= data_inicio) &
        (df['data'].dt.date <= data_fim)
    ]
    
    if df_filtered.empty:
        st.warning("‚ö†Ô∏è Nenhum dado encontrado com os filtros aplicados")
        return
    
    # M√©tricas principais
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("üìä Registros Filtrados", f"{len(df_filtered):,}")
    with col2:
        vel_media = df_filtered['velocidade_km'].mean()
        st.metric("‚ö° Velocidade M√©dia", f"{vel_media:.1f} km/h")
    with col3:
        km_total = df_filtered['odometro_periodo_km'].sum()
        st.metric("üõ£Ô∏è KM Total", f"{km_total:.1f}")
    with col4:
        gps_coverage = (df_filtered['gps'].sum() / len(df_filtered)) * 100
        st.metric("üì° GPS Coverage", f"{gps_coverage:.1f}%")
    
    # Gr√°ficos principais
    col1, col2 = st.columns(2)
    
    with col1:
        # Distribui√ß√£o de velocidade
        fig1 = px.histogram(df_filtered, x='velocidade_km', nbins=30,
                           title="üìä Distribui√ß√£o de Velocidade")
        st.plotly_chart(fig1, use_container_width=True)
    
    with col2:
        # Atividade por hora
        df_filtered['hora'] = df_filtered['data'].dt.hour
        atividade_hora = df_filtered.groupby('hora').size().reset_index(name='Registros')
        fig2 = px.bar(atividade_hora, x='hora', y='Registros',
                      title="üìà Atividade por Hora do Dia")
        st.plotly_chart(fig2, use_container_width=True)

def show_advanced_settings():
    """Configura√ß√µes avan√ßadas do relat√≥rio"""
    st.subheader("‚öôÔ∏è Configura√ß√µes Avan√ßadas")
    
    # Configura√ß√µes de m√©tricas
    st.markdown("### üìä M√©tricas Personalizadas")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.checkbox("üìà Incluir an√°lise de tend√™ncias", value=True)
        st.checkbox("üö® Incluir alertas de seguran√ßa", value=True)
        st.checkbox("‚ö° Incluir m√©tricas de performance", value=True)
        st.checkbox("üó∫Ô∏è Incluir an√°lise geogr√°fica", value=False)
    
    with col2:
        st.number_input("üèéÔ∏è Limite de velocidade (km/h):", min_value=50, max_value=120, value=80)
        st.number_input("üîã Bateria baixa (V):", min_value=10.0, max_value=15.0, value=12.0)
        st.slider("üìä N√∫mero de ve√≠culos no top ranking:", 5, 20, 10)
        
    # Configura√ß√µes de formato
    st.markdown("### üìÑ Formata√ß√£o do Relat√≥rio")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.selectbox("üé® Tema do relat√≥rio:", ["Profissional", "Moderno", "Cl√°ssico"])
        st.selectbox("üìä Estilo dos gr√°ficos:", ["Plotly", "Matplotlib", "Seaborn"])
    
    with col2:
        st.selectbox("üìÑ Tamanho da p√°gina:", ["A4", "Letter", "A3"])
        st.selectbox("üî§ Idioma:", ["Portugu√™s", "English", "Espa√±ol"])

def show_download_options(df, summary, analyzer, tipo_relatorio, formato_saida, incluir_graficos):
    """Op√ß√µes de download do relat√≥rio"""
    st.subheader("üì• Download do Relat√≥rio")
    
    # Informa√ß√µes do relat√≥rio a ser gerado
    st.markdown(f"**üìä Tipo:** {tipo_relatorio}")
    st.markdown(f"**üìÑ Formato:** {formato_saida}")
    st.markdown(f"**üìÖ Per√≠odo:** {len(df):,} registros")
    st.markdown(f"**üöó Ve√≠culos:** {df['placa'].nunique()}")
    
    # Bot√µes de gera√ß√£o
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üìÑ Gerar PDF Profissional", type="primary"):
            with st.spinner("üîÑ Gerando relat√≥rio PDF..."):
                try:
                    generator = PDFReportGenerator()
                    # Usar m√©todo existente at√© implementar o avan√ßado
                    pdf_path = generator.generate_fleet_report()
                    
                    if os.path.exists(pdf_path):
                        with open(pdf_path, "rb") as file:
                            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                            filename = f"relatorio_{tipo_relatorio.split()[1].lower()}_{timestamp}.pdf"
                            
                            st.download_button(
                                label="‚¨áÔ∏è Baixar PDF",
                                data=file.read(),
                                file_name=filename,
                                mime="application/pdf"
                            )
                        st.success("‚úÖ Relat√≥rio PDF gerado com sucesso!")
                    else:
                        st.error("‚ùå Erro ao gerar relat√≥rio PDF")
                except Exception as e:
                    st.error(f"‚ùå Erro: {str(e)}")
    
    with col2:
        if st.button("üìä Exportar Dados CSV"):
            csv_data = df.to_csv(index=False)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"dados_frota_{timestamp}.csv"
            
            st.download_button(
                label="‚¨áÔ∏è Baixar CSV",
                data=csv_data,
                file_name=filename,
                mime="text/csv"
            )
            st.success("‚úÖ Dados CSV prontos para download!")
    
    with col3:
        if st.button("üìà Relat√≥rio Completo"):
            st.info("üöß Gerando relat√≥rio completo (PDF + CSV + Gr√°ficos)...")
            st.markdown("*Funcionalidade em desenvolvimento*")
    
    # Hist√≥rico de relat√≥rios
    st.markdown("### üìã Hist√≥rico de Relat√≥rios")
    st.info("üìÅ √öltimos relat√≥rios gerados aparecer√£o aqui")

# ========== SE√á√ÉO PRINCIPAL - EXECUTADA AP√ìS DEFINI√á√ïES ==========
# Se√ß√£o principal de gera√ß√£o de relat√≥rios
st.header("üìä Gera√ß√£o de Relat√≥rios")

# Tabs para diferentes visualiza√ß√µes
tab1, tab2, tab3, tab4 = st.tabs(["üìã Pr√©-visualiza√ß√£o", "üìä Dashboard", "‚öôÔ∏è Configura√ß√µes", "üì• Download"])

with tab1:
    show_report_preview(df_filtered, summary, analyzer, tipo_relatorio)

with tab2:
    show_report_dashboard(df_filtered, analyzer)

with tab3:
    show_advanced_settings()

with tab4:
    show_download_options(df_filtered, summary, analyzer, tipo_relatorio, formato_saida, incluir_graficos)